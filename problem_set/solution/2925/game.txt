https://blog.csdn.net/qq_43649416/article/details/102888169

=============================上面是链接===================================

首先，对于求答案，有很多种方法，可以O(n)暴力去求，但也可以O(log n)用一个权值线段树去维护。记录当前区间匹配后剩下的a和b的个数。然后对于两个区间由于已经满足了大小，所以直接让左边的a匹配右边的b就好了。
不难证明这样维护是没有问题的。
那么按位贪心。
题解的做法是直接二分这个位置跟哪个b匹配，然后再线段树上删掉这一对a和b。看看最终的答案是否最优。这样是O(n log2n)的。
实际上还有更加优秀的O(n log n)的做法。
我们可以分类讨论。
（1）去掉ai后答案不变。假设ls0表示去掉ai后在线段树的匹配中最大的匹配成功的b，ls1表示最大的未被匹配的b。再分两类讨论：
ls0<=ai，那么ls1一定<=ai（否则ls1就可以和ai匹配了，实际答案就会变大1），又因为我们匹配的时候是小的a尽量匹配小的b（一种显然的O(n)的贪心思路），所以如果用ai去和ls1（或者从ls1开始后往前一段连续被匹配的b中的任何一个）匹配的话，答案就会减1。所以ai只能和ls1匹配。
ls0>ai，ai和ls0匹配就好了，虽然会使ls0已经匹配的那个失去对象，但是同时也加了1，所以没有影响，并且因为ls1<=ai，所以不选ls1。
（2） 去掉ai后答案改变。说明ai是必选的。所以一定有一个空格给ai（保证当前答案的合法性），所以就选ls1。
我们可以在线段树上二分来得到ls0和ls1.